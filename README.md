# CRDT

## Описание
В данном репозитории находится пример реализации бесконфликтно-реплицированных типов данных (CRDT) с использованием гибридных логических часов (HLC).
## Содержание
1. [Введение](#task1)
1. [Почему так мало offline first приложений?](#task2)
1. [Почему синхронизация - это сложно?](#task3)
1. [Как решить проблему упорядочивания событий?](#task4)
1. [Как решить конфликты?](#task5)
1. [Пример приложения](#task6)

### <a name="task1"></a> 1. Введение

Offline first — это парадигма разработки приложений, при которой разработчики гарантируют, что на функциональность приложения не повлияет периодическое отсутствие сетевого подключения.

### <a name="task2"></a> 2. Почему так мало offline first приложений?

Главная проблема в том, что WEB-приложения не приспособлены для работы без интернета и даже если интернет есть, но он очень слабый, то WEB-приложение будет работать медленно и тормозить.

Однако зачастую при создании полностью оффлайн приложения, его создают полностью локальным, весь используемый код, все используемые данные хранятся локально

И, конечно, основная причина почему оффлайн приложений так мало - синхронизация это очень сложно.

Конечно, если наше приложение полностью локальное, то проблем с синхронизацией нет, но в ситуации, когда доступ к приложению возможен с разных устройств мы непременно сталкиваемся со сложностью синхронизации

Некоторые приложения могут заявлять себя как приложения, которые поддерживают оффлайн работу, но при этом когда сеть пропадает появляется оповещение - "Данные могут не сохраниться" - почему бы просто не сказать, что они не сохранятся

Необходимо признать, что оффлайн-приложение это распределенная система данных:
У вас может быть множество узлов - устройств с приложением - и при изменении состояния одного узла, необходимо, чтобы после синхронизации остальные узлы получили это же состояние

### <a name="task3"></a> 3. Почему синхронизация - это сложно?

Синхронизация вызывает сложности по двум причинам:
- Ненадежное упорядочивание
- Конфликты


При наличии двух клиентов нам бы хотелось, чтобы изменения получаемые клиентами были упорядочены, но зачастую этого не происходит

### <a name="task4"></a> 4. Как решить проблему упорядочивания событий?

Как упорядочить события?

1) Использовать метки времени
Но время на различных устройствах может отличаться и в таком случае метки времени нам не нужны, нам нужен относительный порядок

2) Использовать идентификаторы (1, 2, 3..)
Но мы не можем просто использовать идентификаторы, т.к. тогда каждое устройство будет зависеть от глобального идентификаторы и это будет требовать большой согласованности

3) Нам нужны часы! Часы особого типа

Существует много видов часов для синхронизации данных (расширить список)
- Векторные часы
- Гибридные-логические часы

### Гибридные логические часы (HLC)

Данные часы существуют на каждом устройстве. Это не что-то, что хранится на каком-то централизованном сервере, который все используют для синхронизации

HLC генерируют метки времени, которые мы можем назначить каждому событию.

HLC похожи на вектор, состоящий из нескольких записей. HLC позволяют нам по метке времени сравнить изменения и сказать произошло ли это изменение раньше других, т.е. они восстанавливают относительный порядок

HLC использует алгоритм, по которому мы можем сказать:
"Если эта строка с меткой времени меньше, чем другая строка, то данное событие случилось раньше"

### <a name="task5"></a> 5. Как решить конфликты?

Как решить конфликты?

Но что делать с конфликтами, до этого момента мы обсуждали лишь упорядочивание данных, но если два устройства в один и тот же промежуток времени оффлайн произведут изменения - как мы синхронизируем их, когда они выйдут онлайн

1) Ручное разрешение конфликтов
Очень сложно, поскольку существует множество случаев, которые надо обработать
2) CRDTs - Conflict-free Replicated Data Types


**Бесконфликтно-реплицированный тип данных (CRDT)** — это структура данных, упрощающая распределенные системы хранения данных и многопользовательские приложения.

CRDT имеет 2 главных свойства:

- Коммутативность (порядок не имеет значения)
- Идемпотентность (повторность не меняет состояния)

Таким образом, для CRDT не важно в каком порядке и сколько раз вы применяете изменения

(Пример применения CRDT - LWW-Map) - почитать про разные виды CRDT

LWW-Map = Last Write Wins Map
G-set = Grow Only Set


SQLite Table -> G-Set of LWW-Maps

Ничего не удаляем, т.к. все построено на G-Set - просто помечаем tombstone (статус - удален)

### <a name="task6"></a> 6. Пример приложения

Для примера применения CRDT было разработано небольшое тестовое приложение состоящее из клиента и сервера.
